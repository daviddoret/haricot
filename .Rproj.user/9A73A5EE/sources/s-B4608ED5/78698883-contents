t1 <- TruthTable_FlexOutput$new(2,3);
t1$do_randomize_outputs();

# Find the dimensional input size of the original function.
# This will become the output size of the inverse function.
inverse_output_size <- t1$get_input_dimension();

# Find the dimensional output size of the original function.
# This will become the input size of the inverse function.
inverse_input_size <- t1$get_output_dimension();

# Name rows in the truthtable.
# Like this we may reorder them and still match them to their original inputs.
# Here we use the original position as the row identifier.
truthtable_n_n <- t1$get_logical_matrix();
rownames(truthtable_n_n) <- 1 : nrow(truthtable_n_n);
truthtable_n_n
# Get rid of duplicate outputs.
truthtable_unique <- unique(truthtable_n_n);
#print(truthtable_unique);
#print(length(truthtable_unique));

# Initializes an empty truthtable.
# We use all zeros as the default.
inv_truthtable_n_n <- TruthTable_FlexOutput$new(
  input_dimension = inverse_input_size,
  output_dimension = inverse_output_size,
  init_value = FALSE);
#create_truthtable_n_m(n = inv_n, m = inv_m, init_value = FALSE);
print(inv_truthtable_n_n);

for(unique_position in 1:nrow(truthtable_unique)){
  #print(unique_position);
  input_position <- as.integer(rownames(truthtable_unique)[unique_position]);
  print(input_position);
  output_binum <- truthtable_unique[unique_position,];
  print(output_binum);
  # Apply this to the new truthtable
  inv_output_binum <- convert_position_to_logical_vector(input_position, size = inverse_output_size);
  print(inv_output_binum);
  #inv_input_position <- convert_logical_vector_to_position(output_binum);
  inv_input <- output_binum;
  print(inv_input);
  #inv_truthtable_n_n[inv_input_position,] <- inv_output_binum;
  inv_truthtable_n_n$set_output(inv_input, inv_output_binum);
}

# Return the inverted truthtable.
return(inv_truthtable_n_n);