library(truthtables)
find_rtools()
devtools::find_rtools();
install.packages('Rcpp');
library(Rcpp);
library(truthtables)
install.packages('pkgbuild');
devtools::install_github("r-lib/devtools");
library(devtools);
library(installr);
library(Rcpp);
library(pkgbuild);
assignInNamespace("version_info", c(devtools:::version_info, list("3.5" = list(version_min = "3.3.0", version_max = "99.99.99", path = "bin"))), "devtools");
find_rtools();
library(truthtables)
library(truthtables)
library(truthtables)
help(expect_equal)
source('C:/Users/david/OneDrive/Academic Research/truthtables/tests/testthat/test-BinaryNumber_Modular.R', echo=TRUE)
b2 <- BinaryNumber_Modular$new(dimension = 2, init_value = FALSE);
b2$do_print();
b2$print();
b2 <- BinaryNumber_Modular$new(dimension = 2, init_value = FALSE);
b2
b2$do_print();
b2$do_increment();
library(truthtables)
b2$do_print();
b2$do_increment();
library(truthtables)
b2 <- BinaryNumber_Modular$new(dimension = 2, init_value = FALSE);
b2$do_print();
b2$do_increment();
b2
b2$do_print();
library(truthtables)
d1 <- BinaryDomain$new(dimension = 1);
library(truthtables)
d1 <- BinaryDomain$new(dimension = 1);
library(truthtables)
d1 <- BinaryDomain$new(dimension = 1);
d1 <- BinaryDomain$new(dimension = 1);
library(truthtables)
d1 <- BinaryDomain$new(dimension = 1);
library(R6);
BinaryNumber_Modular <- R6Class(
"BinaryNumber_Modular",
public = list(
# Private Members
raw_vector = NULL,
initialize = function(raw_vector = FALSE, dimension = 1) {
self$raw_vector <- rep(raw_vector, dimension);
},
get_bit = function(bit_position){
return(self$raw_vector[bit_position]);
},
get_dimension = function() {
return(length(self$raw_vector));
},
get_prettystring = function() {
return(paste(as.numeric(self$raw_vector), collapse=""));
},
get_raw_vector = function() {
return(self$raw_vector);
},
do_increment = function(){
# do_increment is a function that adds 1 to a "binary number".
# because we use modulo arithmetic, if all bit values are equal to 1 and we increment_binum,
# we should end with all 0s.
# here, we define the left most bit as the least significant bit.
index <- 1;
incremented <- FALSE;
while(index <= self$get_dimension() & !incremented) {
if(self$get_bit(index)){
self$set_bit_0(index);
} else {
self$set_bit_1(index);
incremented <- TRUE;
}
index <- index + 1;
}
# If the incrementation failed here,
# we end up with all 0s.
# This is intentional as we are using modulo arithmetic.
},
do_print = function(){
print(self$get_prettystring());
},
set_bit = function(bit_position, raw_value){
self$raw_vector[bit_position] <- raw_value;
},
set_bit_0 = function(bit_position){
self$set_bit(bit_position = bit_position, raw_value = FALSE);
},
set_bit_1 = function(bit_position){
self$set_bit(bit_position = bit_position, raw_value = TRUE);
}
)
)
d1 <- BinaryDomain$new(dimension = 1);
library(truthtables)
library(truthtables)
d1 <- BinaryDomain$new(dimension = 1);
library(truthtables)
d1 <- BinaryDomain$new(dimension = 1);
library(truthtables)
d1 <- BinaryDomain$new(dimension = 1);
library(truthtables)
d1 <- BinaryDomain$new(dimension = 1);
library(truthtables)
d1 <- BinaryDomain$new(dimension = 1);
library(truthtables)
d1 <- BinaryDomain$new(dimension = 1);
library(truthtables)
d1 <- BinaryDomain$new(dimension = 1);
d1 <- BinaryDomain$new(dimension = 2);
library(truthtables)
d1 <- BinaryDomain$new(dimension = 2);
d1$do_print();
d1$raw_matrix
as.numeric(d1$raw_matrix)
matrix(as.numeric(d1$raw_matrix), nrow = 4);
paste(matrix(as.numeric(d1$raw_matrix), nrow = 4),collapse = "");
help(format)
format(matrix(as.numeric(d1$raw_matrix), nrow = 4),collapse = "");
matrix(as.numeric(d1$raw_matrix), nrow = 4);
rbind(matrix(as.numeric(d1$raw_matrix), nrow = 4));
toRows(matrix(as.numeric(d1$raw_matrix), nrow = 4));
toString(matrix(as.numeric(d1$raw_matrix), nrow = 4));
paste(matrix(as.numeric(d1$raw_matrix), nrow = 4), collapse = "");
help("strwrap")
strwrap(matrix(as.numeric(d1$raw_matrix), nrow = 4), width = 2);
as.numeric(d1$raw_matrix);
strwrap(matrix(as.numeric(d1$raw_matrix), nrow = 4), width = 2);
toString(matrix(as.numeric(d1$raw_matrix), nrow = 4));
paste0(matrix(as.numeric(d1$raw_matrix), nrow = 4));
as.string(matrix(as.numeric(d1$raw_matrix), nrow = 4));
toString(matrix(as.numeric(d1$raw_matrix), nrow = 4));
paste0(matrix(as.numeric(d1$raw_matrix), nrow = 4), collapse = "");
paste(matrix(as.numeric(d1$raw_matrix), nrow = 4), collapse = "");
strwrap(x = paste(matrix(as.numeric(d1$raw_matrix), nrow = 4), collapse = ""), width = 2);
writelines(strwrap(x = paste(matrix(as.numeric(d1$raw_matrix), nrow = 4), collapse = ""), width = 2));
writeLines(strwrap(x = paste(matrix(as.numeric(d1$raw_matrix), nrow = 4), collapse = ""), width = 2));
strwrap(x = paste(matrix(as.numeric(d1$raw_matrix), nrow = 4), collapse = ""), width = 2);
strwrap(x = paste(matrix(as.numeric(d1$raw_matrix), nrow = 4), collapse = ""), width = .2);
help(strwrap)
as.numeric(d1$raw_matrix);
apply(d1$raw_matrix, 1, paste, collapse = "");
matrix(as.numeric(d1$raw_matrix), nrow = 4);
apply(matrix(as.numeric(d1$raw_matrix), nrow = 4), 1, paste, collapse = "")
library(truthtables)
d1 <- BinaryDomain$new(dimension = 2);
d1$do_print();
d1$get_prettystring()
paste(d1$get_prettystring(), collapse = "\n");
cat(paste(d1$get_prettystring(), collapse = "\n"));
library(truthtables)
d1 <- BinaryDomain$new(dimension = 2);
expect_equal(object = d1$get_prettystring(), expected = "1111");
d1$do_print()
library(truthtables)
d1 <- BinaryDomain$new(dimension = 2);
expect_equal(object = d1$get_prettystring(), expected = "1111");
d1 <- BinaryDomain$new(dimension = 2);
d1$get_prettystring()
d1$get_length();
library(truthtables)
d1 <- BinaryDomain$new(dimension = 2);
expect_equal(object = d1$get_prettystring(), expected = "1111");
d1$get_prettystring()
library(truthtables)
d1 <- BinaryDomain$new(dimension = 2);
d1$get_prettystring()
d1$do_print();
library(truthtables)
d1 <- BinaryDomain$new(dimension = 2);
d1$do_print();
d1 <- BinaryDomain$new(dimension = 1);
d1$do_print();
d1 <- BinaryDomain$new(dimension = 3);
d1$do_print();
d1 <- BinaryDomain$new(dimension = 4);
d1$do_print();
o <- "coucou"
print(classOf(o))
o1 <- "coucou"
print(class(o1))
o2 <- c(TRUE,FALSE)
print(class(o2))
o3 <- BinaryNumber_Modular$new()
print(class(o3))
o1 <- "coucou"
print(class(o1))
print(typeof(o1))
o2 <- c(TRUE,FALSE)
print(class(o2))
print(typeof(o2))
o3 <- BinaryNumber_Modular$new()
print(class(o3))
print(typeof(o3))
o1 <- "coucou"
print(class(o1))
print(typeof(o1))
is(o1,character)
is(o1,"character")
is(o3,"BinaryNumber_Modular")
"hello"[3]
strsplit(x = "bonjour", split = "", fixed = TRUE);
strsplit(x = "0011010", split = "", fixed = TRUE);
as.numeric(strsplit(x = "0011010", split = "", fixed = TRUE));
as.logical(strsplit(x = "0011010", split = "", fixed = TRUE));
help("as.logical")
help("as.numeric")
strsplit(x = "0011010", split = "", fixed = TRUE)[[1]];
as.numeric(strsplit(x = "0011010", split = "", fixed = TRUE)[[1]]);
as.logical(as.numeric(strsplit(x = "0011010", split = "", fixed = TRUE)[[1]]));
as.numeric(C(1,0,0,1))
as.numeric(c(1,0,0,1))
as.numeric(c(FALSE,TRUE))
as.character(c(1,0,0,1))
paste(as.character(c(1,0,0,1)),collapse = TRUE)
paste(as.character(c(1,0,0,1)),collapse = "")
?switch
help(is)
help(error)
hepl(warning())
help("warning")
convert_int_to_position <- function(i){
# converter function
# Integers start from 0
# but vector index positions start from 1
return(i + 1);
}
convert_position_to_int <- function(position){
# converter function
# Vector position start from 1
# Integer start from 0
return(position - 1);
}
convert_logical_vector_to_position <- function(logical_vector){
# converter function
return(convert_int_to_position(convert_logical_vector_to_int(logical_vector)));
}
convert_position_to_logical_vector <- function(position, size){
# converter function
i <- convert_position_to_int(position);
logical_vector <- convert_int_to_logical_vector(i, size = size);
return(logical_vector);
}
convert_character_to_logical_vector <- function(input_character){
# Receives a character string composed of "0" and "1" and converts it to logical vector.
numeric_vector <- as.numeric(strsplit(x = input_character, split = "", fixed = TRUE)[[1]]);
logical_vector <- as.logical(numeric_vector);
return(logical_vector);
}
convert_logical_vector_to_character <- function(logical_vector){
# Receives a logical vector and returns a string composed of "0" and "1".
numeric_vector <- as.numeric(logical_vector);
character_vector <- as.character(numeric_vector);
collapsed <- paste(character_vector, collapse = "");
return(collapsed);
}
convert_any_to_logical_vector <- function(input){
# Receives an input of an arbitrary support class and returns a logical vector.
if(is(object = input, class2 = "logical")){
return(input);
} else if(is(object = input, class2 = "character")){
return(convert_character_to_logical_vector(input));
} else if(is(object = input, class2 = "BinaryNumber_Modular")) {
return(input$get_logical_vector());
} else {
# Ooops!
stop(input);
}
}
convert_any_to_logical_vector("10101");
convert_any_to_logical_vector(c(TRUE,FALSE));
convert_any_to_logical_vector(BinaryNumber_Modular(raw_vector = c(TRUE,FALSE));;
convert_any_to_logical_vector(BinaryNumber_Modular$new(raw_vector = c(TRUE,FALSE));;
n <- BinaryNumber_Modular$new(raw_vector = c(TRUE,FALSE));
n
n$get_raw_vector()
n <- BinaryNumber_Modular$new(raw_vector = c(TRUE,FALSE));
convert_any_to_logical_vector(n)
n$get_raw_vector()
library(R6);
BinaryDomain <- R6Class(
# BINUMOSET = Binary Number (Exhaustive) Ordered Set.
# The binary n ordered set is defined as the ordered set of all binary values of dimension n.
"BinaryDomain",
public = list(
# Private Members
dimension = NULL,
raw_matrix = NULL,
initialize = function(dimension = 1) {
# Store private members
self$dimension <- dimension;
self$raw_matrix <- matrix(nrow = 2 ^ dimension, ncol = dimension);
binum <- BinaryNumber_Modular$new(raw_vector = FALSE, dimension = dimension);
index <- 1;
while(index <= 2 ^ dimension){
self$raw_matrix[index,] <- binum$get_raw_vector();
binum$do_increment();
index <- index + 1;
}
},
get_dimension = function() {
return(self$dimension);
},
get_length = function() {
return(nrow(self$raw_matrix));
},
get_prettystring = function() {
# Take a logical matrix reprensenting a truthtable and returns a "pretty" string representation.
num <- as.numeric(self$raw_matrix);
mat <- matrix(num, nrow = self$get_length());
col <- apply(mat, 1, paste, collapse = "");
pas <- paste(col, collapse = "\n");
return(pas);
},
do_print = function(){
cat(self$get_prettystring());
}
)
)
convert_any_to_logical_vector(n)
library(R6);
BinaryNumber_Modular <- R6Class(
"BinaryNumber_Modular",
public = list(
# Private Members
logical_vector = NULL,
initialize = function(logical_vector = FALSE, dimension = 1) {
logical_vector <- NULL;
if(is(logical_vector, "character")){
logical_vector <-
}
self$logical_vector <- rep(logical_vector, dimension);
},
get_bit = function(bit_position){
return(self$logical_vector[bit_position]);
},
get_dimension = function() {
return(length(self$logical_vector));
},
get_logical_vector = function() {
return(self$logical_vector);
},
get_prettystring = function() {
return(paste(as.numeric(self$logical_vector), collapse=""));
},
do_increment = function(){
# do_increment is a function that adds 1 to a "binary number".
# because we use modulo arithmetic, if all bit values are equal to 1 and we increment_binum,
# we should end with all 0s.
# here, we define the left most bit as the least significant bit.
index <- 1;
incremented <- FALSE;
while(index <= self$get_dimension() & !incremented) {
if(self$get_bit(index)){
self$set_bit_0(index);
} else {
self$set_bit_1(index);
incremented <- TRUE;
}
index <- index + 1;
}
# If the incrementation failed here,
# we end up with all 0s.
# This is intentional as we are using modulo arithmetic.
},
do_print = function(){
print(self$get_prettystring());
},
set_bit = function(bit_position, raw_value){
self$logical_vector[bit_position] <- raw_value;
},
set_bit_0 = function(bit_position){
self$set_bit(bit_position = bit_position, raw_value = FALSE);
},
set_bit_1 = function(bit_position){
self$set_bit(bit_position = bit_position, raw_value = TRUE);
}
)
)
library(R6);
BinaryNumber_Modular <- R6Class(
"BinaryNumber_Modular",
public = list(
# Private Members
logical_vector = NULL,
initialize = function(input, dimension = 1) {
self$logical_vector <- convert_any_to_logical_vector(input);
},
get_bit = function(bit_position){
return(self$logical_vector[bit_position]);
},
get_dimension = function() {
return(length(self$logical_vector));
},
get_logical_vector = function() {
return(self$logical_vector);
},
get_prettystring = function() {
return(paste(as.numeric(self$logical_vector), collapse=""));
},
do_increment = function(){
# do_increment is a function that adds 1 to a "binary number".
# because we use modulo arithmetic, if all bit values are equal to 1 and we increment_binum,
# we should end with all 0s.
# here, we define the left most bit as the least significant bit.
index <- 1;
incremented <- FALSE;
while(index <= self$get_dimension() & !incremented) {
if(self$get_bit(index)){
self$set_bit_0(index);
} else {
self$set_bit_1(index);
incremented <- TRUE;
}
index <- index + 1;
}
# If the incrementation failed here,
# we end up with all 0s.
# This is intentional as we are using modulo arithmetic.
},
do_print = function(){
print(self$get_prettystring());
},
set_bit = function(bit_position, raw_value){
self$logical_vector[bit_position] <- raw_value;
},
set_bit_0 = function(bit_position){
self$set_bit(bit_position = bit_position, raw_value = FALSE);
},
set_bit_1 = function(bit_position){
self$set_bit(bit_position = bit_position, raw_value = TRUE);
}
)
)
library(truthtables)
n <- BinaryNumber_Modular$new("101010");
n$do_print();
n$get_logical_vector()
test_that('BinaryNumber_Modular initializes properly', {
b1 <- BinaryNumber_Modular$new(input = "1111");
expect_equal(object = b1$get_prettystring(), expected = "1111");
b1 <- BinaryNumber_Modular$new(input = c(TRUE,FALSE,TRUE,FALSE));
expect_equal(object = b1$get_prettystring(), expected = "1010");
});
library(truthtables)
library(truthtables)
b2 <- BinaryNumber_Modular$new(input = "00");
print(b2)
b2$do_increment()
b2$do_print()
library(truthtables)
library(truthtables)
t1 <- TruthTable_FlexOutput$new(input_dimension = 2, output_dimension = 2, init_value = FALSE);
t1$set_output(input = "10", output = "01");
library(truthtables)
library(truthtables)
t1 <- TruthTable_FlexOutput$new(input_dimension = 2, output_dimension = 2, init_value = FALSE);
t1$set_output(input = "01", output = "11");
library(truthtables)
t1$set_output(input = "01", output = "11");
t1 <- TruthTable_FlexOutput$new(input_dimension = 2, output_dimension = 2, init_value = FALSE);
t1$set_output(input = "01", output = "11");
library(truthtables)
t1 <- TruthTable_FlexOutput$new(input_dimension = 2, output_dimension = 2, init_value = FALSE);
t1$set_output(input = "01", output = "11");
t1$do_apply_algorithm(input = "10");
library(truthtables)
t1 <- TruthTable_FlexOutput$new(input_dimension = 2, output_dimension = 2, init_value = FALSE);
t1$set_output(input = "01", output = "11");
t1$do_apply_algorithm(input = "10");
library(truthtables)
t1 <- TruthTable_FlexOutput$new(input_dimension = 2, output_dimension = 2, init_value = FALSE);
t1$set_output(input = "01", output = "11");
t1$do_apply_algorithm("11");
t1$do_apply_algorithm("01");
library(truthtables)
help("TruthTable_FlexOutput")
library(truthtables)
t1 <- TruthTable_FlexOutput$new(5,6);
t1$do_apply_algorithm("01011");
t1$do_randomize_outputs();
t1$do_apply_algorithm("01011");
t1$logical_matrix
t1$get_input_dimension();
t1$get_output_dimension();
sample(x = FALSE, size = 2 ^ t1$get_input_dimension() * t1$get_output_dimension(), replace = TRUE);
sample(x = TRUE, size = 2 ^ t1$get_input_dimension() * t1$get_output_dimension(), replace = TRUE);
sample(x = 1, size = 2 ^ t1$get_input_dimension() * t1$get_output_dimension(), replace = TRUE);
sample(x = c(TRUE,FALSE), size = 2 ^ t1$get_input_dimension() * t1$get_output_dimension(), replace = TRUE);
BinaryDomain$new(2)
BinaryDomain$new(2);
d <- BinaryDomain(2);
d <- BinaryDomain$new(2);
d
d$do_print();
library(truthtables)
t1 <- TruthTable_FlexOutput$new(5,6);
t1$do_randomize_outputs();
library(truthtables)
t1 <- TruthTable_FlexOutput$new(5,6);
t1$do_randomize_outputs();
t1$do_apply_algorithm("11110")
t1$do_apply_algorithm("11110")
t1$do_apply_algorithm("10110")
library(truthtables)
library(truthtables)
