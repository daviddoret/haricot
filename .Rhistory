# Here we use the original position as the row identifier.
truthtable_n_n <- t1$get_logical_matrix();
rownames(truthtable_n_n) <- 1 : nrow(truthtable_n_n);
# Get rid of duplicate outputs.
truthtable_unique <- unique(truthtable_n_n);
truthtable_n_n
t1 <- TruthTable_FlexOutput$new(2,3, init_value = FALSE);
t1$get_logical_matrix()
t1$do_randomize_outputs();
t1$get_logical_matrix()
library(haricot)
t1 <- TruthTable_FlexOutput$new(2,3, init_value = FALSE);
t1 <- TruthTable_FlexOutput$new(2,3);
t1$do_randomize_outputs();
# Find the dimensional input size of the original function.
# This will become the output size of the inverse function.
inverse_output_size <- t1$get_input_dimension();
# Find the dimensional output size of the original function.
# This will become the input size of the inverse function.
inverse_input_size <- t1$get_output_dimension();
# Name rows in the truthtable.
# Like this we may reorder them and still match them to their original inputs.
# Here we use the original position as the row identifier.
truthtable_n_n <- t1$get_logical_matrix();
rownames(truthtable_n_n) <- 1 : nrow(truthtable_n_n);
truthtable_n_n
# Name rows in the truthtable.
# Like this we may reorder them and still match them to their original inputs.
# Here we use the original position as the row identifier.
truthtable_n_n <- t1$get_logical_matrix();
rownames(truthtable_n_n) <- 1 : nrow(truthtable_n_n);
truthtable_n_n
# Get rid of duplicate outputs.
truthtable_unique <- unique(truthtable_n_n);
# Initializes an empty truthtable.
# We use all zeros as the default.
inv_truthtable_n_n <- TruthTable_FlexOutput$new(
input_dimension = inverse_input_size,
output_dimension = inverse_output_size,
init_value = FALSE);
#create_truthtable_n_m(n = inv_n, m = inv_m, init_value = FALSE);
print(inv_truthtable_n_n);
for(unique_position in 1:nrow(truthtable_unique)){
#print(unique_position);
input_position <- as.integer(rownames(truthtable_unique)[unique_position]);
print(input_position);
output_binum <- truthtable_unique[unique_position,];
print(output_binum);
# Apply this to the new truthtable
inv_output_binum <- convert_position_to_logical_vector(input_position, size = inverse_output_size);
print(inv_output_binum);
#inv_input_position <- convert_logical_vector_to_position(output_binum);
inv_input <- output_binum;
print(inv_input);
#inv_truthtable_n_n[inv_input_position,] <- inv_output_binum;
inv_truthtable_n_n$set_output(inv_input, inv_output_binum);
}
inv_truthtable_n_n
library(haricot)
runif(n = 1, min = 1, max = 6)
help(sample)
library(haricot)
input_dimension = sample(x = 1:6, size = 1);
output_dimension = sample(x = 1:6, size = 2);
input_dimension = sample(x = 1:6, size = 1);
output_dimension = sample(x = 1:6, size = 2);
output_dimension = sample(x = 1:6, size = 1);
input_dimension = as.integer(sample(x = 1:6, size = 1));
input_dimension = sample(x = 1:6, size = 1);
output_dimension = sample(x = 1:6, size = 1);
t1 <- TruthTable_FlexOutput$new(input_dimension, output_dimension);
t1$do_randomize_outputs();
t1 <- TruthTable_FlexOutput(3,4);
t1$do_randomize_outputs();
t1 <- TruthTable_FlexOutput$new(3,4);
t1$do_randomize_outputs();
num <- as.numeric(t1$get_logical_matrix());
mat <- matrix(num, nrow = self$get_length());
library(haricot)
t1 <- TruthTable_FlexOutput$new(3,4);
t1$do_randomize_outputs();
num <- as.numeric(t1$get_logical_matrix());
mat <- matrix(num, nrow = t1$get_input_size());
mat
col <- apply(mat, 1, paste, collapse = "");
col
d$get_logical_matrix()
d <- BinaryDomain$new(t1$get_input_dimension());
d$get_logical_matrix()
library(haricot)
t1 <- TruthTable_FlexOutput$new(3,4);
t1$do_randomize_outputs();
num <- as.numeric(t1$get_logical_matrix());
mat <- matrix(num, nrow = t1$get_input_size());
col <- apply(mat, 1, paste, collapse = "");
col
d <- BinaryDomain$new(t1$get_input_dimension());
d$get_logical_matrix()
t1 <- TruthTable_FlexOutput$new(3,4);
t1$do_randomize_outputs();
output_integer_vector <- as.numeric(t1$get_logical_matrix());
output_integer_matrix <- matrix(output_integer_vector, nrow = t1$get_input_size());
output_character_vector <- apply(output_integer_matrix, 1, paste, collapse = "");
output_character_vector
d <- BinaryDomain$new(t1$get_input_dimension());
d$get_logical_matrix()
input_integer_vector <- as.numeric(d$get_logical_matrix());
input_integer_matrix <- matrix(input_integer_vector, nrow = t1$get_input_size());
input_character_vector <- apply(input_integer_matrix, 1, paste, collapse = "");
input_character_vector
input_character_vector & "-->" & output_character_vector
input_character_vector + "-->" + output_character_vector
c(input_character_vector, output_character_vector)
x <- c(input_character_vector, rep(">", t1$get_input_size()), output_character_vector)
matrix(x, ncol = 3, nrow = t1$get_input_size())
xm <- matrix(x, ncol = 3, nrow = t1$get_input_size())
apply(xm, 1, paste, collapse = "");
paste(apply(xm, 1, paste, collapse = ""), collapse = "\n");
p <- paste(apply(xm, 1, paste, collapse = ""), collapse = "\n");
print(p);
cat(p);
x <- c(input_character_vector, rep(" > ", t1$get_input_size()), output_character_vector)
xm <- matrix(x, ncol = 3, nrow = t1$get_input_size())
p <- paste(apply(xm, 1, paste, collapse = ""), collapse = "\n");
cat(p);
library(haricot)
input_dimension = sample(x = 1:6, size = 1);
output_dimension = sample(x = 1:6, size = 1);
t1 <- TruthTable_FlexOutput$new(input_dimension, output_dimension);
t1$do_randomize_outputs();
print(t1);
input_dimension = sample(x = 1:6, size = 1);
output_dimension = sample(x = 1:6, size = 1);
t1 <- TruthTable_FlexOutput$new(input_dimension, output_dimension);
t1$do_randomize_outputs();
print(t1);
random_input_integer <- sample(x = 0:2 ^ input_dimension - 1, size = 1);
random_input_logical_vector <- convert_int_to_logical_vector(random_input_integer);
random_input_logical_vector <- convert_int_to_logical_vector(random_input_integer, size = input_dimension);
output <- t1$do_apply_algorithm(random_input_logical_vector);
t2 <- t1$get_inverse();
library(haricot)
input_dimension = sample(x = 1:6, size = 1);
output_dimension = sample(x = 1:6, size = 1);
t1 <- TruthTable_FlexOutput$new(input_dimension, output_dimension);
t1$do_randomize_outputs();
print(t1);
random_input_integer <- sample(x = 0:2 ^ input_dimension - 1, size = 1);
random_input_logical_vector <- convert_int_to_logical_vector(random_input_integer, size = input_dimension);
output <- t1$do_apply_algorithm(random_input_logical_vector);
t2 <- t1$get_inverse();
inverse_output <- t2$do_apply_algorithm(output);
library(haricot)
input_dimension = sample(x = 1:6, size = 1);
output_dimension = sample(x = 1:6, size = 1);
t1 <- TruthTable_FlexOutput$new(input_dimension, output_dimension);
t1$do_randomize_outputs();
random_input_integer <- sample(x = 0:2 ^ input_dimension - 1, size = 1);
random_input_logical_vector <- convert_int_to_logical_vector(random_input_integer, size = input_dimension);
output <- t1$do_apply_algorithm(random_input_logical_vector);
t2 <- t1$get_inverse();
inverse_output <- t2$do_apply_algorithm(output);
library(haricot)
library(haricot)
browser()
devtools::test()
devtools::test()
devtools::test()
library(haricot)
devtools::test()
devtools::test()
library(haricot)
devtools::test()
devtools::test()
input_dimension = sample(x = 1:6, size = 1);
output_dimension = sample(x = 1:6, size = 1);
t1 <- TruthTable_FlexOutput$new(input_dimension, output_dimension);
t1$do_randomize_outputs();
print(t1);
random_input_integer <- sample(x = 0:2 ^ input_dimension - 1, size = 1);
random_input_logical_vector <- convert_int_to_logical_vector(random_input_integer, size = input_dimension);
output <- t1$do_apply_algorithm(random_input_logical_vector);
t2 <- t1$get_inverse();
print(t2);
input_dimension = 2 #sample(x = 1:6, size = 1);
output_dimension = 3 #sample(x = 1:6, size = 1);
input_dimension = 2 #sample(x = 1:6, size = 1);
output_dimension = 3 #sample(x = 1:6, size = 1);
t1 <- TruthTable_FlexOutput$new(input_dimension, output_dimension);
t1$do_randomize_outputs();
print(t1);
library(haricot)
input_dimension = 2 #sample(x = 1:6, size = 1);
output_dimension = 3 #sample(x = 1:6, size = 1);
t1 <- TruthTable_FlexOutput$new(input_dimension, output_dimension);
t1$do_randomize_outputs();
print(t1);
random_input_integer <- sample(x = 0:2 ^ input_dimension - 1, size = 1);
random_input_logical_vector <- convert_int_to_logical_vector(random_input_integer, size = input_dimension);
output <- t1$do_apply_algorithm(random_input_logical_vector);
t2 <- t1$get_inverse();
print(t2);
library(haricot)
input_dimension = 2 #sample(x = 1:6, size = 1);
output_dimension = 3 #sample(x = 1:6, size = 1);
t1 <- TruthTable_FlexOutput$new(input_dimension, output_dimension);
t1$do_randomize_outputs();
print(t1);
random_input_integer <- sample(x = 0:2 ^ input_dimension - 1, size = 1);
random_input_logical_vector <- convert_int_to_logical_vector(random_input_integer, size = input_dimension);
output <- t1$do_apply_algorithm(random_input_logical_vector);
t2 <- t1$get_inverse();
print(t2);
t1$get_output_dimension()
t1$get_inverse()
library(haricot)
t1 <- TruthTable_FlexOutput(2,3);
t1 <- TruthTable_FlexOutput(2,3);
t1 <- TruthTable_FlexOutput$new(2,3);
# Find the dimensional input size of the original function.
# This will become the output size of the inverse function.
inverse_output_dimension <- t1$get_input_dimension();
t1
# Find the dimensional input size of the original function.
# This will become the output size of the inverse function.
inverse_output_dimension <- t1$get_input_dimension();
# Find the dimensional output size of the original function.
# This will become the input size of the inverse function.
inverse_input_dimension <- t1$get_output_dimension();
t1 <- TruthTable_FlexOutput$new(2,3);
t1$do_randomize_outputs()
t1
# Find the dimensional input size of the original function.
# This will become the output size of the inverse function.
inverse_output_dimension <- t1$get_input_dimension();
# Find the dimensional output size of the original function.
# This will become the input size of the inverse function.
inverse_input_dimension <- t1$get_output_dimension();
# Name rows in the truthtable.
# Like this we may reorder them and still match them to their original inputs.
# Here we use the original position as the row identifier.
logical_matrix_copy <- t1$get_logical_matrix();
rownames(logical_matrix_copy) <- 1 : nrow(logical_matrix_copy);
# Get rid of duplicate outputs.
logical_matrix_unique <- unique(logical_matrix_copy);
# Initializes an empty truthtable.
# We use all zeros as the default.
inverse_truthtable <- TruthTable_FlexOutput$new(
input_dimension = inverse_input_dimension,
output_dimension = inverse_output_dimension);
for(unique_position in 1:nrow(logical_matrix_unique)){
input_position <- as.integer(rownames(logical_matrix_unique)[unique_position]);
output_logical_vector <- logical_matrix_unique[unique_position,];
# Apply this to the new truthtable
inverse_output_logical_vector <- convert_position_to_logical_vector(input_position, size = inverse_output_dimension);
inverse_input_logical_vector <- output_logical_vector;
inverse_truthtable$set_output(inverse_input_logical_vector, inverse_output_logical_vector);
}
# Return the inverted truthtable.
print(inverse_truthtable);
# Initializes an empty truthtable.
# We use all zeros as the default.
inverse_truthtable <- TruthTable_FlexOutput$new(
input_dimension = inverse_input_dimension,
output_dimension = inverse_output_dimension);
inverse_truthtable
View(logical_matrix_copy)
t1 <- TruthTable_FlexOutput$new(3,2);
t1$do_randomize_outputs()
t1
# Find the dimensional input size of the original function.
# This will become the output size of the inverse function.
inverse_output_dimension <- t1$get_input_dimension();
# Find the dimensional output size of the original function.
# This will become the input size of the inverse function.
inverse_input_dimension <- t1$get_output_dimension();
# Name rows in the truthtable.
# Like this we may reorder them and still match them to their original inputs.
# Here we use the original position as the row identifier.
logical_matrix_copy <- t1$get_logical_matrix();
rownames(logical_matrix_copy) <- 1 : nrow(logical_matrix_copy);
# Get rid of duplicate outputs.
logical_matrix_unique <- unique(logical_matrix_copy);
# Initializes an empty truthtable.
# We use all zeros as the default.
inverse_truthtable <- TruthTable_FlexOutput$new(
input_dimension = inverse_input_dimension,
output_dimension = inverse_output_dimension);
inverse_truthtable
TruthTable_FlexOutput$new(4,2)
# Initializes an empty truthtable.
# We use all zeros as the default.
inverse_truthtable <- TruthTable_FlexOutput$new(inverse_input_dimension,inverse_output_dimension);
inverse_truthtable
# Initializes an empty truthtable.
# We use all zeros as the default.
inverse_truthtable <- TruthTable_FlexOutput$new(2,3);
inverse_truthtable
library(haricot)
library(haricot)
TruthTable_FlexOutput(3,4)
TruthTable_FlexOutput$new(3,4)
library(haricot)
t1 <- TruthTable_FlexOutput$new(3,2);
t1$do_randomize_outputs()
t1
# Find the dimensional input size of the original function.
# This will become the output size of the inverse function.
inverse_output_dimension <- t1$get_input_dimension();
# Find the dimensional output size of the original function.
# This will become the input size of the inverse function.
inverse_input_dimension <- t1$get_output_dimension();
# Name rows in the truthtable.
# Like this we may reorder them and still match them to their original inputs.
# Here we use the original position as the row identifier.
logical_matrix_copy <- t1$get_logical_matrix();
rownames(logical_matrix_copy) <- 1 : nrow(logical_matrix_copy);
# Get rid of duplicate outputs.
logical_matrix_unique <- unique(logical_matrix_copy);
# Initializes an empty truthtable.
# We use all zeros as the default.
inverse_truthtable <- TruthTable_FlexOutput$new(inverse_input_dimension,inverse_output_dimension);
inverse_truthtable
for(unique_position in 1:nrow(logical_matrix_unique)){
input_position <- as.integer(rownames(logical_matrix_unique)[unique_position]);
output_logical_vector <- logical_matrix_unique[unique_position,];
# Apply this to the new truthtable
inverse_output_logical_vector <- convert_position_to_logical_vector(input_position, size = inverse_output_dimension);
inverse_input_logical_vector <- output_logical_vector;
inverse_truthtable$set_output(inverse_input_logical_vector, inverse_output_logical_vector);
}
# Return the inverted truthtable.
print(inverse_truthtable);
help(expect_equal)
random_input_logical_vector == inverse_output
input_dimension = sample(x = 1:6, size = 1);
output_dimension = sample(x = 1:6, size = 1);
t1 <- TruthTable_FlexOutput$new(input_dimension, output_dimension);
t1$do_randomize_outputs();
random_input_integer <- sample(x = 0:2 ^ input_dimension - 1, size = 1);
random_input_logical_vector <- convert_int_to_logical_vector(random_input_integer, size = input_dimension);
output <- t1$do_apply_algorithm(random_input_logical_vector);
t2 <- t1$get_inverse();
inverse_output <- t2$do_apply_algorithm(output);
expect_equal(random_input_logical_vector, inverse_output, info = c(t1, t2, random_input_logical_vector));
sample(x = 0:2 ^ input_dimension - 1, size = 1);
sample(x = 0:2 ^ input_dimension - 1, size = 1);
sample(x = 0:2 ^ input_dimension - 1, size = 1);
sample(x = 0:2 ^ input_dimension - 1, size = 1);
sample(x = 0:2 ^ input_dimension - 1, size = 1);
sample(x = 0:2 ^ input_dimension - 1, size = 1);
sample(x = 0:2 ^ input_dimension - 1, size = 1);
sample(x = 0:2 ^ input_dimension - 1, size = 1);
input_dimension = sample(x = 1:6, size = 1);
output_dimension = sample(x = 1:6, size = 1);
output_dimension = sample(x = 1:6, size = 1);
t1 <- TruthTable_FlexOutput$new(input_dimension, output_dimension);
output_dimension = sample(x = 1:6, size = 1);
output_dimension = sample(x = 1:6, size = 1);
output_dimension = sample(x = 1:6, size = 1);
output_dimension = sample(x = 1:6, size = 1);
output_dimension = sample(x = 1:6, size = 1);
input_dimension = 2 #sample(x = 1:6, size = 1);
output_dimension = 3 #sample(x = 1:6, size = 1);
t1 <- TruthTable_FlexOutput$new(input_dimension, output_dimension);
t1$do_randomize_outputs();
random_input_integer <- sample(x = 0:2 ^ input_dimension - 1, size = 1);
random_input_logical_vector <- convert_int_to_logical_vector(random_input_integer, size = input_dimension);
output <- t1$do_apply_algorithm(random_input_logical_vector);
input_dimension = 2 #sample(x = 1:6, size = 1);
output_dimension = 3 #sample(x = 1:6, size = 1);
t1 <- TruthTable_FlexOutput$new(input_dimension, output_dimension);
t1$do_randomize_outputs();
print(t1);
random_input_integer <- sample(x = 0:2 ^ input_dimension - 1, size = 1);
random_input_logical_vector <- convert_int_to_logical_vector(random_input_integer, size = input_dimension);
output <- t1$do_apply_algorithm(random_input_logical_vector);
t2 <- t1$get_inverse();
print(t2);
inverse_output <- t2$do_apply_algorithm(output);
expect_equal(random_input_logical_vector, inverse_output, info = c(t1, t2, random_input_logical_vector));
input_dimension = 2 #sample(x = 1:6, size = 1);
output_dimension = 3 #sample(x = 1:6, size = 1);
t1 <- TruthTable_FlexOutput$new(input_dimension, output_dimension);
t1$do_randomize_outputs();
print(t1);
random_input_integer <- sample(x = 0:2 ^ input_dimension - 1, size = 1);
random_input_logical_vector <- convert_int_to_logical_vector(random_input_integer, size = input_dimension);
output <- t1$do_apply_algorithm(random_input_logical_vector);
t2 <- t1$get_inverse();
print(t2);
inverse_output <- t2$do_apply_algorithm(output);
expect_equal(random_input_logical_vector, inverse_output, info = c(t1, t2, random_input_logical_vector));
input_dimension = 3 #sample(x = 1:6, size = 1);
output_dimension = 2 #sample(x = 1:6, size = 1);
t1 <- TruthTable_FlexOutput$new(input_dimension, output_dimension);
t1$do_randomize_outputs();
print(t1);
random_input_integer <- sample(x = 0:2 ^ input_dimension - 1, size = 1);
random_input_logical_vector <- convert_int_to_logical_vector(random_input_integer, size = input_dimension);
output <- t1$do_apply_algorithm(random_input_logical_vector);
t2 <- t1$get_inverse();
print(t2);
inverse_output <- t2$do_apply_algorithm(output);
expect_equal(random_input_logical_vector, inverse_output, info = c(t1, t2, random_input_logical_vector));
for(iteration in 1:8){
input_dimension = 3 #sample(x = 1:6, size = 1);
output_dimension = 2 #sample(x = 1:6, size = 1);
t1 <- TruthTable_FlexOutput$new(input_dimension, output_dimension);
t1$do_randomize_outputs();
print(t1);
random_input_integer <- sample(x = 0:2 ^ input_dimension - 1, size = 1);
random_input_logical_vector <- convert_int_to_logical_vector(random_input_integer, size = input_dimension);
output <- t1$do_apply_algorithm(random_input_logical_vector);
t2 <- t1$get_inverse();
print(t2);
inverse_output <- t2$do_apply_algorithm(output);
expect_equal(random_input_logical_vector, inverse_output, info = c(t1, t2, random_input_logical_vector));
}
input_dimension = 2 #sample(x = 1:6, size = 1);
output_dimension = 2 #sample(x = 1:6, size = 1);
t1 <- TruthTable_FlexOutput$new(input_dimension, output_dimension);
t1$do_randomize_outputs();
print(t1);
random_input_integer <- sample(x = 0:2 ^ input_dimension - 1, size = 1);
random_input_logical_vector <- convert_int_to_logical_vector(random_input_integer, size = input_dimension);
output <- t1$do_apply_algorithm(random_input_logical_vector);
t2 <- t1$get_inverse();
print(t2);
inverse_output <- t2$do_apply_algorithm(output);
expect_equal(random_input_logical_vector, inverse_output, info = c(t1, t2, random_input_logical_vector));
for(iteration in 1:8){
input_dimension = 2 #sample(x = 1:6, size = 1);
output_dimension = 2 #sample(x = 1:6, size = 1);
t1 <- TruthTable_FlexOutput$new(input_dimension, output_dimension);
t1$do_randomize_outputs();
print(t1);
random_input_integer <- sample(x = 0:2 ^ input_dimension - 1, size = 1);
random_input_logical_vector <- convert_int_to_logical_vector(random_input_integer, size = input_dimension);
output <- t1$do_apply_algorithm(random_input_logical_vector);
t2 <- t1$get_inverse();
print(t2);
inverse_output <- t2$do_apply_algorithm(output);
expect_equal(random_input_logical_vector, inverse_output, info = c(t1, t2, random_input_logical_vector));
}
t2
t1
for(iteration in 1:8){
input_dimension = 2 #sample(x = 1:6, size = 1);
output_dimension = 2 #sample(x = 1:6, size = 1);
t1 <- TruthTable_FlexOutput$new(input_dimension, output_dimension);
t1$do_randomize_outputs();
print(t1);
random_input_integer <- sample(x = 0:2 ^ input_dimension - 1, size = 1);
random_input_logical_vector <- convert_int_to_logical_vector(random_input_integer, size = input_dimension);
output <- t1$do_apply_algorithm(random_input_logical_vector);
t2 <- t1$get_inverse();
print(t2);
inverse_output <- t2$do_apply_algorithm(output);
new_input <- inverse_output;
new_output <- t1$do_apply_algorithm(new_input);
expect_equal(output, new_output, info = c(t1, t2, random_input_logical_vector));
}
for(iteration in 1:8){
input_dimension = 2 #sample(x = 1:6, size = 1);
output_dimension = 3 #sample(x = 1:6, size = 1);
t1 <- TruthTable_FlexOutput$new(input_dimension, output_dimension);
t1$do_randomize_outputs();
print(t1);
random_input_integer <- sample(x = 0:2 ^ input_dimension - 1, size = 1);
random_input_logical_vector <- convert_int_to_logical_vector(random_input_integer, size = input_dimension);
output <- t1$do_apply_algorithm(random_input_logical_vector);
t2 <- t1$get_inverse();
print(t2);
inverse_output <- t2$do_apply_algorithm(output);
new_input <- inverse_output;
new_output <- t1$do_apply_algorithm(new_input);
expect_equal(output, new_output, info = c(t1, t2, random_input_logical_vector));
}
for(iteration in 1:8){
input_dimension = 3 #sample(x = 1:6, size = 1);
output_dimension = 2 #sample(x = 1:6, size = 1);
t1 <- TruthTable_FlexOutput$new(input_dimension, output_dimension);
t1$do_randomize_outputs();
print(t1);
random_input_integer <- sample(x = 0:2 ^ input_dimension - 1, size = 1);
random_input_logical_vector <- convert_int_to_logical_vector(random_input_integer, size = input_dimension);
output <- t1$do_apply_algorithm(random_input_logical_vector);
t2 <- t1$get_inverse();
print(t2);
inverse_output <- t2$do_apply_algorithm(output);
new_input <- inverse_output;
new_output <- t1$do_apply_algorithm(new_input);
expect_equal(output, new_output, info = c(t1, t2, random_input_logical_vector));
}
library(haricot)
for(iteration in 1:8){
input_dimension = 3 #sample(x = 1:6, size = 1);
output_dimension = 2 #sample(x = 1:6, size = 1);
t1 <- TruthTable_FlexOutput$new(input_dimension, output_dimension);
t1$do_randomize_outputs();
print(t1);
random_input_integer <- sample(x = 0:2 ^ input_dimension - 1, size = 1);
random_input_logical_vector <- convert_int_to_logical_vector(random_input_integer, size = input_dimension);
output <- t1$do_apply_algorithm(random_input_logical_vector);
t2 <- t1$get_inverse();
print(t2);
inverse_output <- t2$do_apply_algorithm(output);
new_input <- inverse_output;
new_output <- t1$do_apply_algorithm(new_input);
expect_equal(output, new_output, info = c(t1, t2, random_input_logical_vector));
}
