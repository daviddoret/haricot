% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fun_equal_bnum.R, R/man_bnum_equality.R,
%   R/man_transforming_truthtables_into_dag.R
\name{equal_bnum}
\alias{equal_bnum}
\alias{man_bnum_equality}
\title{equal_bnum}
\usage{
equal_bnum(n1, n2)
}
\arguments{
\item{n1}{A modular binary number (logical vector, character vector, bnum)}

\item{n2}{A modular binary number (logical vector, character vector, bnum)}
}
\value{
Returns TRUE if n1 and n2 are equal, FALSE otherwise (logical vector of length 1)
}
\description{
Tells us if two bnum objects are equal.
}
\section{Theory}{


\subsection{Equality of Modular Binary Numbers}{
In the context of this package, two modular binary numbers are equal if and only if they have identical dimensions and all their corresponding bits are equal. \cr
Formally: \cr
\deqn{\forall i \in \mathbb{N}^+ , (a,b) \in \mathbb{B}_{i} : a=b \iff |a| = |b|, \forall j \in [1,...,i] , a_{i} = b_{i}}
}
A consequence of this definition of equality is that 2 modular binary numbers may be mapped to the same natural number and not be considered equal.\cr
For instance: \cr



\subsection{Transforming truth tables into DAG}{
I'll provide more details as soon as I have a moment to document this. \cr
But haricot has now a logically neutral transformation,
that takes an arbitrary truth table algorithm as input,
and transforms it into a DAG algorithm.}
}

\examples{
equal_bnum(bnum$new("1101"), bnum$new("110"));
equal_bnum(bnum$new("1101"), bnum$new("1100"));
equal_bnum(bnum$new("1101"), bnum$new("1101"));
equal_bnum(bnum$new("000"), bnum$new("0000"));
equal_bnum(bnum$new("000"), bnum$new("000"));

# Create a random truth table algorithm with input dimension 8 and output dimension 8:
truthtable <- algo_tt$new(8,8)$do_randomize_outputs();
# Display the upper part of the truth table in the console:
cat(substr(truthtable$get_prettystring(),1,200));
# Transform the truth table to a DAG algorithm:
dag <- atomize(truthtable);
#

}
