---
title: "Magic Tables"
output:
  html_document:
    df_print: paged
---

# TECHNICAL SETUP

```{r}
#install.packages("devtools");
library(devtools)

#install.packages("R6")
library(R6)

# install 'binaryLogic'
#install_github("d4ndo/binaryLogic")
library(binaryLogic)
```

# MAGIC TABLES

## NAMING CONVENTIONS

###Standard Verbs
The following verbs are used to organize R functions in the form verb_object_complement:

* create_ (Date Structures)
* compute_ (Values)
* increment_, decrement_, etc. (Values)
* build_ (Algorithms)
* inverse_ (Algorithms)
* convert_ (Data Structure A --> Data Structure B)

#Dimension Suffixes

* _1
* _n
* _1_1
* _1_n
* _n_1
* _n_n

### create_binum_0
The atomic binary number with value 0 and size 1.

```{r}
create_binum_0 <- function(){
  return(FALSE);
}
```

#### create_binum_0 test

```{r}
identical(create_binum_0(), c(FALSE));
```

### BINUM 1
The atomic binary number with value 1 and size 1.

```{r}
create_binum_1 <- function(){
  return(TRUE);
}
```

```{r}
create_binum_1();
```





## BINUMOSET
A binary number ordered (exhaustive) set.

### BINUMOSET 1
R data structure: logical vector of size 2.

```{r}
create_binumoset_1 <- function(){
  return(c(
      create_binum_0(),
      create_binum_1()));
}
```

### BINUMOSET 1 TEST

```{r}
identical(create_binumoset_1(), c(FALSE,TRUE));
```


## LOGICAL FUNCTIONS

NAND is defined as the "not and"" function

```{r}

```

```{r}
compute_nand(create_binum_0(),create_binum_0())
compute_nand(create_binum_0(),create_binum_1())
compute_nand(create_binum_1(),create_binum_0())
compute_nand(create_binum_1(),create_binum_1())
```



## TRUTHTABLES

### TRUTHTABLE N x 1

R data structure: a logical vector of size 2 ^ N

To store and manage truthtables with an input of arbitrary size N and an output of size 1, we will use a logical vector of size 2 ^ N. The logical values in the vector represent the output binums of the truthtable. 
It is not necessary to store the input of the truthtable in the truthtable data structure because we will use the vector index position of the output to infer the input. For instance:
Vector index position = 1 --> Input = binum of value 0.
Vector index position = 2 --> Input = binum of value 1.
Vector index position = 3 --> Input = binum of value 3.
...
Vector index position = 2 ^ N --> Input = binum of value 2 ^ N - 1.

### TRUTHTABLE N x M


### Function: create_truthtable_n_1
R data structure: logical vector of size 2^n.

```{r}
create_truthtable_n_1 <- function(size, init_value){
  return(rep(init_value, 2 ^ size));
}
```



### compute_truthtable_n_1_input_size

By definition, the dimensional input size of a truthtable of size N x 1 = N.
By definition, the input size of a truthtable of size N x 1 = 2 ^ N.
Because we use a logical vector R data structure, we can retrieve the input size with: log2(number of items in the vector).

```{r}
compute_truthtable_n_1_input_size <- function(truthtable_n_1){
  return(log2(length(truthtable_n_1)));
}
```

#### Test: compute_truthtable_n_1_input_size

```{r}
compute_truthtable_n_1_input_size(rep(FALSE,2));
compute_truthtable_n_1_input_size(rep(FALSE,4));
compute_truthtable_n_1_input_size(rep(FALSE,8));
compute_truthtable_n_1_input_size(rep(FALSE,16));
```

### compute_truthtable_n_n_input_size

By definition, the dimensional input size of a truthtable of size N x M = N.
By definition, the input size of a truthtable of size N x M = 2 ^ N.
Because we use a logical matrix as an R data structure, we can retrieve the input size with: log2(number of rows in the matrix).

```{r}
compute_truthtable_n_n_input_size <- function(truthtable_n_n){
  return(log2(nrow(truthtable_n_n)));
}
```

### COMPUTE TRUTHTABLE NxN INPUT SIZE

```{r}
compute_truthtable_n_n_input_size(matrix(ncol=8,nrow=32));
```

### COMPUTE TRUTHTABLE NxN OUTPUT SIZE

```{r}
compute_truthtable_n_n_output_size <- function(truthtable_n_n){
  return(ncol(truthtable_n_n));
}
```

### COMPUTE TRUTHTABLE NxN OUTPUT SIZE TEST

```{r}
compute_truthtable_n_n_output_size(matrix(ncol=5, nrow=17));
```

### Function: build_truthtable_n_1_random

This function creates a truthtable of size N x 1 with pseudo-random outputs.

```{r}
build_truthtable_n_1_random <- function(n){
    return(sample(x = create_binumoset_1(), size = 2 ^ n, replace = TRUE));
}
```


#### Test

```{r}
build_truthtable_n_1_random(n = 1);
build_truthtable_n_1_random(n = 2);
build_truthtable_n_1_random(n = 3);
build_truthtable_n_1_random(n = 4);
```

### Function: build_truthtable_n_n_random

This function creates a truthtable of size N x M with pseudo-random outputs.

```{r}
build_truthtable_n_n_random <- function(n, m){

}
```


#### Test

```{r}
build_truthtable_n_n_random(n = 2, m = 3);
build_truthtable_n_n_random(n = 3, m = 2);
build_truthtable_n_n_random(n = 4, m = 4);
```

### Function: inverse_truthtable_n_1_any

By definition, a truthtable is a function.
Let f be a truthtable of dimension n x 1.
By definition, the domain of f = the set of binary numbers of dimensional size n (noted binumoset n).
By definition, the codomain of f = the set of binary numbers of dimension size 1 (noted binumoset 1).
Let f-1 be an inverse function of f such that when y = f-1(x), then f(y) = x.
Because |binumoset_n| >= |binumoset_1| when n > 1, f-1 may be "incomplete" in the sense that its codomain will be a subset of f's domain.
Function inverse_truthtable_n_1_any creates an inverse of a truthtable of size N x 1 by picking any available values such that when y = f-1(x), f(y) = x holds true. But many other inverse truthtables may be valid as well.

```{r}
inverse_truthtable_n_1_any <- function(truthtable_n_1){
  
  # Find the dimensional input size of the original function.
  n <- compute_truthtable_n_1_input_size(truthtable_n_1 = truthtable_n_1);
  
  # Find x such that f(x) = 0.
  position0 <- match(x = FALSE, table = truthtable_n_1);
  # If there is no x such that f(x) = 0, then any value will be valid. Arbitrarily use a default of 0.
  x0 <- FALSE;
  if(!is.na(position0)){
    # Infer the value of x from the position.
    x0 <- convert_position_to_bit_vector(position = position0, size = n);
  }
  
  # Find x such that f(x) = 1.
  position1 <- match(x = TRUE, table = truthtable_n_1);
  
  # If there is no x such that f(x) = 0, then any value will be valid. Arbitrarily use a default of 0.
  x1 <- FALSE;
  if(!is.na(position1)){
    # Infer the value of x from the position.
    x1 <- convert_position_to_bit_vector(position = position1, size = n);
  }
  
  # Put everything in a matrix.
  m <- matrix(c(x0,x1), nrow = 2, byrow = TRUE);
  
  # Return the inverted truthtable.
  return(m);
}
```



```{r}
inverse_truthtable_n_n_any <- function(truthtable_n_n){
  
  # Find the dimensional input size of the original function.
  # This will become the output size of the inverse function.
  n <- compute_truthtable_n_n_input_size(truthtable_n_n = truthtable_n_n);
  inv_m <- n;
  
  # Find the dimensional output size of the original function.
  # This will become the input size of the inverse function.
  m <- compute_truthtable_n_n_output_size(truthtable_n_n = truthtable_n_n);
  inv_n <- m;
  
  # Name rows in the truthtable. 
  # Like this we may reorder them and still match them to their original inputs.
  # Here we use the original position as the row identifier.
  rownames(truthtable_n_n) <- 1 : nrow(truthtable_n_n);
  
  # Get rid of duplicate outputs.
  truthtable_unique <- unique(truthtable_n_n);
  #print(truthtable_unique);
  #print(length(truthtable_unique));
  
  # Initializes an empty truthtable.
  # We use all zeros as the default.
  inv_truthtable_n_n <- create_truthtable_n_m(n = inv_n, m = inv_m, init_value = FALSE);
  #print(inv_truthtable_n_n);
  
  for(unique_position in 1:nrow(truthtable_unique)){
    #print(unique_position);
    input_position <- as.integer(rownames(truthtable_unique)[unique_position]);
    #print(input_position);
    output_binum <- truthtable_unique[unique_position,];
    #print(output_binum);
    # Apply this to the new truthtable
    inv_output_binum <- convert_position_to_bit_vector(input_position, size = inv_m);
    inv_input_position <- convert_bit_vector_to_position(output_binum);
    inv_truthtable_n_n[inv_input_position,] <- inv_output_binum;
  }
  
  # Return the inverted truthtable.
  return(inv_truthtable_n_n);
}
```

```{r}

#REPRENDRE LE TRAVAIL ICI

n <- 4;
m <- 3;

print("The original truthtable")
t <- build_truthtable_n_n_random(n, m);
print(prettyfy_truthtable_n_m(t));

inv_t <- inverse_truthtable_n_n_any(t);
print("The inverse truthtable");
print(prettyfy_truthtable_n_m(inv_t));

a <- build_algo_truthtable_n_n(t);
inv_a <- build_algo_truthtable_n_n(t);

print("A sample input value for f-1:")
x_int <- sample(x = 1:2 ^ m, size = 1, replace = TRUE);
x <- convert_int_to_bit_vector(x_int, size = m);
y <- inv_a(x);
cat("f-1(", prettyfy_binum(x), ") = ", prettyfy_binum(y), "\n");
x2 <- a(y);
cat("f(", prettyfy_binum(y), ") = ", prettyfy_binum(x2), "\n");
```



## ALGO

### build_algo_truthtable_n_1
An Algorithm based on a Truthtable with input of size N and output of size 1.

```{r}
build_algo_truthtable_n_1 <- function(truthtable_n_1){
  # truthtable: a boolean vector of size 2^n.
  # output: an algorithm based on a truth table.
  # TODO: check truthtable is of correct size and type.
  algo <- function(input_bit_vector) {
    position <- convert_bit_vector_to_position(input_bit_vector);
    return(truthtable_n_1[position]);
  }
  # metadata decoration.
  attr(algo,"logical_type","logical_algorithm");
  attr(algo,"mechanism","truthtable");
  attr(algo,"truthtable",truthtable_n_1);
  attr(algo,"input_size", compute_truthtable_n_1_input_size(truthtable_n_1));
  attr(algo,"output_size",1);
  return(algo);
}
```

TEST

```{r}
a <- build_algo_truthtable_n_1(c(TRUE,FALSE,FALSE,TRUE));
a(c(FALSE,FALSE));
a(c(TRUE,FALSE));
a(c(FALSE,TRUE));
a(c(TRUE,TRUE));
```

```{r}
build_algo_truthtable_n_n <- function(truthtable_n_n){
  # truthtable: a logical matrix.
  # output: an algorithm based on a truth table.
  # TODO: check truthtable is of correct size and type.
  algo <- function(input_bit_vector) {
    position <- convert_bit_vector_to_position(input_bit_vector);
    return(truthtable_n_n[position,]);
  }
  # metadata decoration.
  attr(algo,"logical_type","logical_algorithm");
  attr(algo,"mechanism","truthtable");
  attr(algo,"truthtable",truthtable_n_n);
  attr(algo,"input_size", compute_truthtable_n_n_input_size(truthtable_n_n));
  attr(algo,"output_size",1);
  return(algo);
}
```

### invert_algo_truthtable_n_1_any

```{r}
# 
# TODO: REPRENDRE CA CORRECTEMENT
# 
# invert_algo_truthtable_n_1_any <- function(algo_truthtable_n_1){
#   # Find the first occurence of a 0 in the output of the original function.
#   truthtable <- attr(algo_truthtable_n_1, "truthtable");
#   which(!truthtable)[1]
#   # Find the first occurence of a 1 in the output of the original function.
#   
#   inversed_truthtable_1_n <- algo_truthtable_n_1(truthtable);
# 
#   # metadata decoration.
#   attr(inversed_algo,"logical_type","logical_algorithm");
#   attr(inversed_algo,"mechanism","truthtable");
#   attr(inversed_algo,"truthtable",inversed_truthtable_1_n);
#   attr(inversed_algo,"input_size", compute_truthtable_n_n_input_size(truthtable_n_n));
#   attr(inversed_algo,"output_size",1);
# 
#   
#   }
# invert_algo_truthtable_n_1_all <- function(){
#   print("HELLO WORLD");
# }
```

## TESTS

### Test: Build a random truthtable-specified function of dimension Nx1, invert it and confirm that the inverse function is correct.

Observations:
1). When n > 16, I start encountering memory issues with my laptop.
2). Since the inverse algo lazily finds the first occurences of 0 and 1 in the original truthtable, 0 is always a solution and the second solution is never far away due to the random nature of the truthtable. Of course, a non-random truthtable could lead to a much longer search for instance if the only solution is the maximal value of the truthtable, the loop will take more time to execute.

```{r}
n <- 16;
t <- build_truthtable_n_1_random(n = n);
# print(t);
f <- build_algo_truthtable_n_1(t);
t_inv <- inverse_truthtable_n_1_any(t);
f_inv <- build_algo_truthtable_n_n(t_inv);
for(position in 1 : 2 ^ 1){
  x <- convert_position_to_bit_vector(position = position, size = 1);
  cat("f-1(", x, ") =", f_inv(x), " and f(", f_inv(x), ") =", f(f_inv(x)), ")", "\n");
}

```


